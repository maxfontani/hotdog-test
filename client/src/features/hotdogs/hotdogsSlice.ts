import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState } from "../../app/store";
import {
  fetchHotdogs,
  addHotdogAsync,
  editHotdogAsync,
  deleteHotdogAsync,
} from "./hotdogsAPI";
import { sortByTitle, consoleLogError } from "../utils";
import {
  IHotdogsState,
  IHotdog,
  INewHotdog,
  IDraftHotdog,
} from "../../app/types";

const initialState: IHotdogsState = {
  allHotdogs: [],
  status: "idle",
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getHotdogsThunk = createAsyncThunk(
  "staff/fetchHotdogsThunk",
  async () => {
    // The value we return becomes the `fulfilled` action payload
    try {
      return await fetchHotdogs();
    } catch (error) {
      return consoleLogError(error);
    }
  }
);

export const addHotdogThunk = createAsyncThunk(
  "staff/addHotdogThunk",
  async (newHotdog: INewHotdog) => {
    // The value we return becomes the `fulfilled` action payload
    try {
      const response = await addHotdogAsync(newHotdog);
      if (response.length && response[0].id) {
        const addedHotdog: IHotdog = Object.assign(newHotdog, {
          ...response[0],
        });
        return addedHotdog;
      } else {
        return undefined;
      }
    } catch (error) {
      return consoleLogError(error);
    }
  }
);

export const editHotdogThunk = createAsyncThunk(
  "staff/editHotdogThunk",
  async (params: { id: number; draftHotdog: IDraftHotdog }) => {
    // The value we return becomes the `fulfilled` action payload
    try {
      const { id, draftHotdog } = params;
      // Server API returns the modified hotdog draft object in an Array, e.g. [{id: 4, title: "New Title"}]
      const response = await editHotdogAsync(id, draftHotdog);
      return response[0];
    } catch (error) {
      return consoleLogError(error);
    }
  }
);

export const deleteHotdogThunk = createAsyncThunk(
  "staff/deleteHotdogThunk",
  async (id: number) => {
    // The value we return becomes the `fulfilled` action payload
    try {
      // Server API returns the deleted id in an Array, e.g. [18]
      return await deleteHotdogAsync(id);
    } catch (error) {
      return consoleLogError(error);
    }
  }
);

export const hotdogsSlice = createSlice({
  name: "hotdogs",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Use the PayloadAction type to declare the contents of `action.payload`

    resetState: (state) => {
      state.allHotdogs = initialState.allHotdogs;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getHotdogsThunk.pending, (state) => {
        state.status = "loading";
      })
      .addCase(
        getHotdogsThunk.fulfilled,
        (state, action: PayloadAction<IHotdog[] | undefined>) => {
          if (action.payload) {
            state.allHotdogs = action.payload;
            state.status = "idle";
          } else {
            state.status = "failed";
          }
        }
      )
      // ON ADD
      .addCase(addHotdogThunk.pending, (state) => {
        state.status = "loading";
      })
      .addCase(
        addHotdogThunk.fulfilled,
        (state, action: PayloadAction<IHotdog | undefined>) => {
          if (action.payload) {
            state.allHotdogs.push(action.payload);
            state.status = "idle";
          } else {
            alert("Oops, something went wrong..");
            state.status = "failed";
          }
        }
      )
      // ON DELETE
      .addCase(deleteHotdogThunk.pending, (state) => {
        state.status = "loading";
      })
      .addCase(
        deleteHotdogThunk.fulfilled,
        (state, action: PayloadAction<Array<number>>) => {
          state.status = "idle";
          if (action.payload && action.payload.length) {
            state.status = "idle";
            state.allHotdogs = state.allHotdogs.filter(
              (hotdog) => hotdog.id !== action.payload[0]
            );
          } else {
            alert("Oops, something went wrong..");
            state.status = "failed";
          }
        }
      )
      // ON EDIT
      .addCase(editHotdogThunk.pending, (state) => {
        state.status = "loading";
      })
      .addCase(
        editHotdogThunk.fulfilled,
        (state, action: PayloadAction<any>) => {
          state.status = "idle";
          if (action.payload && Object.keys(action.payload).includes("id")) {
            state.status = "idle";
            const editedHotdog: IHotdog = state.allHotdogs.filter(
              (hotdog) => hotdog.id === action.payload.id
            )[0];
            const editedIndex = state.allHotdogs.indexOf(editedHotdog);
            Object.assign(state.allHotdogs[editedIndex], { ...action.payload });
          } else {
            alert("Something went wrong..");
            state.status = "failed";
          }
        }
      );
  },
});

export const { resetState } = hotdogsSlice.actions;

// The functions below are called a selector and allow us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectAllHotdogs = (state: RootState): IHotdog[] =>
  state.hotdogs.allHotdogs;

export const selectHotdogById =
  (id: number | undefined) =>
  (state: RootState): IHotdog | undefined => {
    if (id) {
      return state.hotdogs.allHotdogs.filter((hotdog) => hotdog.id === id)[0];
    } else {
      return undefined;
    }
  };

export const selectStatus = (state: RootState): IHotdogsState["status"] =>
  state.hotdogs.status;

export const selectHotdogsOrderedByTitle = (state: RootState): IHotdog[] => {
  if (!state.hotdogs.allHotdogs.length) return [];
  return sortByTitle(selectAllHotdogs(state));
};

export default hotdogsSlice.reducer;
